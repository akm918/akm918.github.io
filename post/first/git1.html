<!doctype html>
<html lang="en-us">
  <head>
    <title>[转载]软件测试-黑盒测试 // AKM918的博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.73.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://akm918.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="性能测试"/>
<meta name="twitter:description" content="test
等价类划分法
边界值法
因果图法
测试大纲法
场景法
判定表法"/>

    <meta property="og:title" content="性能测试" />
<meta property="og:description" content="test
等价类划分法
边界值法
因果图法
测试大纲法
场景法
判定表法" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://akm918.github.io/post/first/" />
<meta property="article:published_time" content="2020-07-03T00:00:16+08:00" />
<meta property="article:modified_time" content="2020-07-03T00:00:16+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://akm918.github.io/"><img class="app-header-avatar" src="/tt.jpg" alt="John Doe" /></a>
      <h1>AKM918</h1>
      <p>个人博客，闲暇之余会写一些关于开发或者测试文章，让我们一起努力吧，一起创造这个世界！</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">性能测试</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jul 3, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      <div class="htmledit_views" id="content_views">
        <h2><a name="t0"></a><a name="t0"></a>1.概述</h2>

<p>黑盒测试也称功能测试或数据驱动测试，它是在已知产品所应具有的功能，通过测试来检验每个功能都是否能够正常使用。</p>

<p>在测试时，把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，测试人员进行直接测试，检查系统功能是否按照需求规格说明书的规定正常使用、是否能适当的接收输入数据而输出正确的结果等，检查相应的文档是否采用了正确的模板、是否满足规范需求。</p>

<h2><a name="t1"></a><a name="t1"></a>2. “黑盒”的两种基本方法&nbsp;</h2>

<p>黑盒测试有两种基本方法，即“通过测试”和“失败测试”。</p>

<p>在进行<span style="color:#3399ea;">“通过测试”时，实际上是确认软件能做什么，而不会考验其能力如何。</span>软件测试员只运用最简单、直观的测试案例。</p>

<p>在<span style="color:#3399ea;">设计和执行测试案例时，总是先进行通过测试。在进行破坏性试验之前，看一看软件基本功能是否能够实现。</span></p>

<p>在确信了软件正确运行之后，就可以采取各种手段通过搞垮软件来找出缺陷。<span style="color:#3399ea;">纯粹为了破坏软件而设计和执行的测试案例，被称为失败测试或迫使出错测试。</span></p>

<h2><a name="t2"></a><a name="t2"></a><span style="color:#0b0123;">3.黑盒测试的优、缺点</span></h2>

<h3><a name="t3"></a><a name="t3"></a>（1）优点</h3>

<p><span style="color:#001003;">a.比较简单，不需要了解程序内部的代码以及实现。</span></p>

<p><span style="color:#001003;">b.与软件内部实现无关。</span></p>

<p><span style="color:#001003;">c.从用户角度出发，很容易的知道用户会用到哪些功能，会遇到哪些问题。</span></p>

<p><span style="color:#001003;">d.在做软件自动化测试时较为方便。</span></p>

<p><span style="color:#001003;">e.基于软件开发文档，所以也能知道软件实现了文档中的哪些功能。</span></p>

<h3><a name="t4"></a><a name="t4"></a>(2)缺点</h3>

<p style="margin-left:0pt;">a.不可能覆盖所有代码，覆盖率较低，大概只能达到总代码量的30%。</p>

<p style="margin-left:0pt;">b.自动化测试的复用性较低。</p>

<h2 style="margin-left:0pt;"><a name="t5"></a><a name="t5"></a>4.黑盒测试的测试用例设计方法</h2>

<p>（1）等价类划分法</p>

<p>（2）边界值分析法</p>

<p>（3）错误推测法</p>

<p>（4）因果图法</p>

<p>（5）判定表</p>

<p>（6）功能图法</p>

<h2><a name="t6"></a><a name="t6"></a>4.1等价类划分法</h2>

<p><strong>（1）概念</strong></p>

<p>等价类划分法就是解决如何选择适当的数据子集来代表整个数据集的问题，通过降低测试的数目去实现“合理的”覆盖，覆盖了更多的可能数据，以发现更多的软件缺陷。</p>

<p>等价类是指某个输入域的一个特定的子集合，在该子集合各个输入数据对于揭露程序中的错误都是等效的。</p>

<p><strong>（2）等价类划分的过程</strong></p>

<p>a.分类：即将输入域按照具有相同特性并用实例来表征这个特性。</p>

<p>b.抽象：即在各个子类中去抽象出相同特性并用实例来表征进行分类。</p>

<p><strong>（3）等价类划分的优缺点</strong></p>

<p>a.优点：基于相对较少的测试用例，就能够进行完整覆盖，很多程度上减少了重复性。</p>

<p>b.缺点：缺乏特殊用例的考虑，同时需要深入的系统知识，才能选择有效的数据。</p>

<p>（<strong>4）有效等价类和无效等价类</strong></p>

<p>（1）有效等价类是指输入完全满足程序输入的规格说明、有意义的输入数据所构成的集合，利用有效等价类，可以检验程序是否满足规格说明所规定的功能和性能。</p>

<p>（2）无效等价类和有效等价类相反，即不满足程序输入要求或者无效的输入数据构成的集合。使用无效等价类，可以测试程序/系统的容错性——对异常输入情况的处理。</p>

<p><strong>（5）不同情形的处理</strong></p>

<div class="table-box"><table align="center" border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:265px;">输入条件</td>
<td style="text-align:center;width:154px;">有效等价类</td>
<td style="text-align:center;width:178px;">无效等价类</td>
</tr><tr><td style="width:265px;">
<p>规定了取值范围或个数的条条件</p>

<p>(输入条件满足小于100大于10的整数x)</p>
</td>
<td style="text-align:center;width:154px;">
<p>1个</p>

<p>10&lt;x&lt;100</p>
</td>
<td style="text-align:center;width:178px;">
<p>2个</p>

<p>x&lt;10和x&gt;100</p>
</td>
</tr><tr><td style="width:265px;">
<p>规定了输入值的集合或者规定了“必须如何”的条件下</p>

<p>(输入条件为x=10)</p>

<p>&nbsp;</p>
</td>
<td style="text-align:center;width:154px;">
<p>1个</p>

<p>x=10</p>

<p>&nbsp;</p>
</td>
<td style="text-align:center;width:178px;">
<p>1个</p>

<p>x≠10</p>
</td>
</tr><tr><td style="width:265px;">
<p>规定了输入条件是一个布尔量</p>

<p>（输入条件bool x = ture）</p>
</td>
<td style="text-align:center;width:154px;">
<p>1个</p>

<p>x = true</p>
</td>
<td style="text-align:center;width:178px;">
<p>1个</p>

<p>x = false</p>
</td>
</tr><tr><td style="width:265px;">
<p>规定了一组输入数据（包括n个输入值），对每一个输入值分别处理</p>

<p>（输入条件为x取值于一个固定枚举类型｛1,3,5,7,9｝）</p>
</td>
<td style="text-align:center;width:154px;">
<p>n个</p>

<p>x∈｛1,3,5,7,9｝</p>
</td>
<td style="text-align:center;width:178px;">
<p>1个</p>

<p>x不属于｛1,3,5,7,9｝的集合</p>
</td>
</tr><tr><td style="width:265px;">
<p>规定了输入数据必须遵守规则的情况下</p>

<p>（输入是页面用户输入有效的Email地址的规则，必须满足几个条件，含有@，@后面格式为x，x,Email地址不带有特殊符号）</p>
</td>
<td style="text-align:center;width:154px;">
<p>1个</p>

<p>满足所有条件的输入集合</p>
</td>
<td style="text-align:center;width:178px;">
<p>n个</p>

<p>不满足其中任何一个条件或所有条件的输入集合</p>
</td>
</tr><tr><td style="width:265px;">在已知的等价类中各元素在程序处理中的方式不同的情况下，则应再将等价类进一步划分为更小的等价类。</td>
<td style="text-align:center;width:154px;">&nbsp;</td>
<td style="text-align:center;width:178px;">&nbsp;</td>
</tr></tbody></table></div><p><strong>（7）案例</strong></p>

<p>有一报表处理系统，要求用户输入处理报表的日期。假设日期在2000年1月至2020年12月，即系统只能对该段时期内的报表进行处理。如果用户不再这个范围内，则显示错误信息。并且此系统规定日期由年月的6位数字组成，前4位代表年，后2位代表月。</p>

<div class="table-box"><table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>输入</td>
<td>有效等级类</td>
<td>无效等价类</td>
</tr><tr><td>报表日期</td>
<td>（1）6位数字字符</td>
<td>
<p>（2）少于6位数字字符</p>

<p>（3）多余6位数字字符</p>

<p>（4）有非数字字符</p>
</td>
</tr><tr><td>年份范围</td>
<td>（5）在2000年到2020年之间</td>
<td>
<p>（6）小于2000</p>

<p>（7）大于2020</p>
</td>
</tr><tr><td>月份范围</td>
<td>（8）在1到12月之间</td>
<td>
<p>（9）等于0</p>

<p>（10）大于12</p>
</td>
</tr></tbody></table></div><h3><a name="t7"></a><a name="t7"></a>4.2边界值分析法</h3>

<p><strong>（1）概念</strong></p>

<p>边界值分析法就是在某个输入输入变量范围的边界上，验证系统功能是否正常运行的测试方法。</p>

<p><strong>（2）与等价划分类的区别</strong></p>

<p>a.边界值分析不是从等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。</p>

<p>b.边界值分析不仅考虑输入条件，还有考虑输出空间产生的测试情况。</p>

<p><strong>（3）边界值分析的处理技巧</strong></p>

<p>a.如果输入条件规定了值的范围，则取刚刚到达这个范围的边界值。</p>

<p>b.如果输入条件规定了值的个数，则用最大个数、最小个数、比最大个数多一个，比最小个数少一个的数等作为测试数据。</p>

<p>c.根据规格说明的每一个输出条件，分别使用以上两个规则。</p>

<p>d.如果程序的规格说明给出的输入域或输出域是有序集合（如有序表、顺序文件等），则应选取集合的第一个和最后一个元素测试数据。</p>

<p><strong>（4）边界值附近的数据确定的几种方法</strong></p>

<div class="table-box"><table border="1" cellpadding="1" cellspacing="1" style="width:698px;"><tbody><tr><td style="width:51px;">项</td>
<td style="width:137px;">边界值</td>
<td style="width:506px;">测试用例的设计思路</td>
</tr><tr><td style="width:51px;">字符</td>
<td style="width:137px;">起始-1个字符/结束+1个字符</td>
<td style="width:506px;">假设一个文本输入区域要求允许输入1-255个字符，输入1个和255个作为有效等价类，输入0个和256个作为无效等价类，这几个数值都属于边界条件值。</td>
</tr><tr><td style="width:51px;">数值</td>
<td style="width:137px;">开始位-1/结束位-1</td>
<td style="width:506px;">例如，数据的输入域为1-999，其值最小为1，最大值为999,1000刚好在边界值附近。</td>
</tr><tr><td style="width:51px;">方向</td>
<td style="width:137px;">刚刚超过/刚刚低于</td>
<td style="width:506px;">&nbsp;</td>
</tr><tr><td style="width:51px;">空间</td>
<td style="width:137px;">小于空余空间一点/大于空余空间一点</td>
<td style="width:506px;">例如，测试数据存储时，使用比最小剩余空间大一点（几KB）的文件作为最大值检验的边界条件。</td>
</tr></tbody></table></div><h3><a name="t8"></a><a name="t8"></a>4.3错误推测法</h3>

<p><strong>（1）概念</strong></p>

<p>错误推测法是基于经验和直觉推测程序中所有可能存在的各种情况，从而有针对性的设计，列出测试用例的方法。</p>

<p>错误推测法基于这样一个思想，在某处发现了缺陷，则可能隐藏更多的缺陷。在实际操作中列出所有可能出现的错误和容易发现错误的地方，然后语句测试者经验做出选择。</p>

<p><strong>（2）优点与缺点</strong></p>

<p>优点：充分发挥人的直觉与经验，在一个测试小组中集思广益，方便实用，特别是在软件测试基础较差的情况下，很好地组织测试小组进行错误推测，是一种有效的测试方法。</p>

<p>使测试者能够快速且容易地切入，并且能够体会到程序的易用与否。</p>

<p>缺点：错误推测法不是一个系统的测试方法，所以只能用着辅助手段，即先用上述方法设计测试用例，在没有其他方法可用的情况下，再采用错误推测法，补充一些例子进行额外的测试。</p>

<p>难以知道测试的覆盖率，可能丢失大量未知的区域，并且这种测试行为带有主观性且难以复制。</p>

<h3><a name="t9"></a><a name="t9"></a>4.4因果图法</h3>

<p><strong>（1）概念</strong></p>

<p>因果图法借助图形，着重分析输入条件的各种组合，每种组合条件就是“因”，它必然有一个输出结果，这就是“果“。</p>

<p>因果图是一种形式化的图形语言，由自然写成的规范转换而成，这种形式化的语言实际上一种简化记号表示数组逻辑图，不仅能发现输入输出中的错误，还能指出程序规范中的不完成性和二义性。</p>

<p>因果图方法最终生成的就是判断表，它适合于检查程序输入条件的各种组合情况。</p>

<p><strong>（2）因果图介绍</strong></p>

<p>1）因果图中使用了简单的逻辑符号，以直线联接左右结点。左结点表示输入状态（原因），右结点表示状输出态（结果）。ci表示原因，通常位于图的左边;ei表示结果，通常位于图的右边。ci和ei均可取值0或1,0表示某状态不出现，1表示某状态出现。如下图：</p>

<p style="text-align:center;"><img alt="因果图" class="has" src="https://img-blog.csdnimg.cn/20190625074430123.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lldXRleWlldGly,size_16,color_FFFFFF,t_70"></p>

<p>&nbsp;</p>

<p>4种符号分别表示了规格说明书中4中因果关系。如上如所示</p>

<p>a.恒等:若ci是1，则ei也是1；否则ei为0.</p>

<p>b.非：若ci是1，则ei是0；否则ei为1。</p>

<p>c.或：若c1或c2或c3是1，则ei是1；否则ei为0.“或可以有任意个输入”。</p>

<p>d.与：若c1和c2都是1，则ei为1;否则ei为0.“与可以有任意个输入”。</p>

<p>2）因果图概念——约束</p>

<p>A.输入条件的约束：</p>

<p>a:<strong>E约束（异）</strong>：a和b中至多有一个可能为1,即a和b不能同时为1.</p>

<p>b.<strong>I约束（或）</strong>：a、b和 中至少有一个必须是1，即a、b和c不能同时为0.</p>

<p>c.<strong>O约束（唯一）</strong>：a和b必须有一个，且仅有一个为1.</p>

<p>d. <strong>R约束（要求）</strong>：a是1时，b必须是1，即不可能a是1是b是0.</p>

<p style="text-align:center;"><img alt="约束" class="has" height="210" src="https://img-blog.csdnimg.cn/20190625085144899.jpg" width="266"></p>

<p>B.输出条件的约束：</p>

<p>输出条件的约束只有<strong>M约束（强制）</strong>，若结果a是1，则结果b强制为0.</p>

<p><strong>（3）利用因果图生成参数用例的步骤</strong></p>

<p>a.分析软件规格说明描述中，那些是原因（即输入条件或输入条件等价类），那些是结果（即输出条件），并给每个原因和结果赋予一个标识符。</p>

<p>b.分析软件规格说明书描述中的语义。找出原因与结果之间，原因与原因之间对应关系。根据这些关系，画出因果图。</p>

<p>c.由于语法和环境限制，有些原因与原因之间，原因与结果之间的组合情况不可能出现。为表明这些特殊情况，在因果图上用一些记号表明约束或限制条件。</p>

<p>d.把因果图转换为判定表。</p>

<p><strong>（4）因果图案例</strong></p>

<p>例：某软件规格说明书包含这样的要求：第一列字符必须是A或B，第二列字符必须是一个数字，在此情况下进行文件的修改，但如果第一列字符不正确，则给出信息L；如果第二列字符不是数字，则给出信息M。</p>

<p>解：</p>

<p>A:根据题意：原因和结果如下</p>

<p>原因：1——第一列字符是A; 2——第一列字符是B; 3——第二列字符是数字。</p>

<p>结果：21——修改文件； 22——给出信息L； 3——给出信息M。</p>

<p>B.对应的因果图</p>

<p>11为中间节点；不考虑原因1和原因2，不可能同时为1，因此在因果图上施加E约束。&nbsp;</p>

<p style="text-align:center;"><img alt="ygt" class="has" height="242" src="https://img-blog.csdnimg.cn/20190625082254175.jpg" width="280"></p>

<p style="text-align:center;"><img alt="判定表" class="has" src="https://img-blog.csdnimg.cn/20190625082614915.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lldXRleWlldGly,size_16,color_FFFFFF,t_70"></p>

<p style="text-align:center;"><img alt="测试用例" class="has" src="https://img-blog.csdnimg.cn/20190625082718378.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lldXRleWlldGly,size_16,color_FFFFFF,t_70"></p>

<h3><a name="t10"></a><a name="t10"></a>4.5功能图法</h3>

<p><strong>（1）概念</strong></p>

<p>功能图法是用功能图FD形式化地表示程序的功能说明，并机械地生成功能图的测试用例。</p>

<p>功能图模型由状态迁移图和逻辑功能模型构成。状态迁移用于表示输入数据序列以及相应的输出数据，在状态迁移图中，由输入数据和当前状态绝对输出数据和后续状态。</p>

<p><strong>（2）功能图</strong></p>

<p>功能图由状态迁移图和布尔函数组成。状态迁移图用状态和迁移来描述，一个状态指出数据输入的位置（或时间），而迁移则指明状态的改变，同时要依靠判定表或因果图表示的逻辑功能。</p>

<p><strong>（3）测试用例的生成方法</strong></p>

<p>从功能图生成测试用例，得到的测试用例数是可接受的。问题的关键是如何从状态迁移图中选取测试用例，若用节点代替状态，用弧线代替迁移，则状态迁移图可转化成一个程序的控制流程图形式。问题就转化称为程序的路径测试了。</p>

<p><strong>（4）测试用例生成规则</strong></p>

<p>为了将状态迁移（测试路径）的测试用例与逻辑模型（局部测试用例）的测试用例组合起来，从功能图生成实用的测试用例，须定义以下规则：在一个结构化的状态迁移中，定义三种形式的循环结构：顺序、选择和重复。但分辨一个状态迁移中所有循环是有困难的。</p>

<p>（5）从功能图中生成测试用例的过程</p>

<p>a.生成局部测试用例：在每个状态中，从因果图生成局部测试用例，局部测试用例由原因值（输入数据）组合与对应结果值（生输出数据或状态）组成。</p>

<p>b.测试路径生成：利用上面的规则（三种）生成从初始状态到最后状态的测试路径。</p>

<p>c.测试用例合成：合成测试路径与功能图中每个状态局部测试用例，结果是初始状态到最后状态的一个状态序列，以及每个状态中输入数据与对应的输出数据的组合。</p>

<h2><a name="t11"></a><a name="t11"></a>5.流程</h2>

<h3><a name="t12"></a><a name="t12"></a>（1）测试计划</h3>

<p>首先，根据用户需求报告中关于功能要求和性能指标的规格说明书，定义相应的测试需求报告，即制订黑盒测试的最高标准，以后所有的测试工作都将围绕着测试需求来进行，符合测试需求的<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F" rel="nofollow">应用程序</a>即是合格的，反之即是不合格的；同时，还要适当选择测试内容，合理安排测试人员、测试时间及测试资源等。</p>

<h3><a name="t13"></a><a name="t13"></a><a name="3_2"></a> <a name="sub51274_3_2"></a> <a name="测试设计"></a> <a name="3-2"></a></h3>

<h3><a name="t14"></a><a name="t14"></a>（2）测试设计</h3>

<p><span>将</span><a href="https://baike.baidu.com/item/%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92" rel="nofollow"><span>测试计划</span></a><span>阶段制订的测试需求分解、细化为若干个可执行的</span><a href="https://baike.baidu.com/item/%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B" rel="nofollow"><span>测试过程</span></a><span>，并为每个测试过程选择适当的</span><a href="https://baike.baidu.com/item/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B" rel="nofollow"><span>测试用例</span></a><span>（测试用例选择的好坏将直接影响到测试结果的有效性）。</span></p>

<p><a name="3_3"></a> <a name="sub51274_3_3"></a> <a name="测试开发"></a> <a name="3-3"></a></p>

<h3><a name="t15"></a><a name="t15"></a>（3）测试开发</h3>

<p>建立可重复使用的自动<a href="https://baike.baidu.com/item/%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B" rel="nofollow">测试过程</a>。</p>

<p><a name="3_4"></a> <a name="sub51274_3_4"></a> <a name="测试执行"></a> <a name="3-4"></a></p>

<h3><a name="t16"></a><a name="t16"></a>（4）测试执行</h3>

<p><span>执行测试开发阶段建立的自动</span><a href="https://baike.baidu.com/item/%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B" rel="nofollow"><span>测试过程</span></a><span>，并对所发现的</span><a href="https://baike.baidu.com/item/%E7%BC%BA%E9%99%B7" rel="nofollow"><span>缺陷</span></a><span>进行</span><a href="https://baike.baidu.com/item/%E8%B7%9F%E8%B8%AA%E7%AE%A1%E7%90%86" rel="nofollow"><span>跟踪管理</span></a><span>。测试执行一般由</span><a href="https://baike.baidu.com/item/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" rel="nofollow"><span>单元测试</span></a><span>、组合测试、</span><a href="https://baike.baidu.com/item/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95" rel="nofollow"><span>集成测试</span></a><span>、系统联调及</span><a href="https://baike.baidu.com/item/%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95" rel="nofollow"><span>回归测试</span></a><span>等步骤组成，测试人员应本着科学负责的态度，</span><a href="https://baike.baidu.com/item/%E4%B8%80%E6%AD%A5%E4%B8%80%E4%B8%AA%E8%84%9A%E5%8D%B0" rel="nofollow"><span>一步一个脚印</span></a><span>地进行测试。</span></p>

<p><a name="3_5"></a> <a name="sub51274_3_5"></a> <a name="测试评估"></a> <a name="3-5"></a></p>

<h3><a name="t17"></a><a name="t17"></a>（5）测试评估</h3>

<p><span>结合量化的</span><a href="https://baike.baidu.com/item/%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96" rel="nofollow"><span>测试覆盖</span></a><span>域及</span><a href="https://baike.baidu.com/item/%E7%BC%BA%E9%99%B7" rel="nofollow"><span>缺陷</span></a><span>跟踪报告，对于</span><a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6" rel="nofollow"><span>应用软件</span></a><span>的质量和开发团队的工作进度及工作效率进行综合评价。</span></p>

<p>&nbsp;</p>

      </div>




    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>